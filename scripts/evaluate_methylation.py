#!/usr/bin/env python3
'''
Script to evaluate methylation.
Takes in 2 per read methylation tsv files generated by megalodon.
One corresponds to lossless (treated as ground truth) and other is for lossy.
Also takes in methylation type of interest (dcm/dam) and threshold (explained below).
First goes through lossless file and collects "ground truth" methylation calls 
(based on threshold).
Then goes through lossy file and collects predicted methylation calls
(again based on the threshold)
Prints number of ground truth calls, predicted calls, precision and recall
'''

import math
import argparse

def evaluate_methylation(infile_lossless, infile_lossy, methylation_type, threshold):
    log_threshold = math.log(threshold)
    if methylation_type == 'dcm':
        methylation_motif = 'CCWGG:1'
    elif methylation_type == 'dam':
        methylation_motif = 'GATC:1'
    # first read ground truth calls into set with entries (read_id,chrm,strand,pos)
    ground_truth_calls = set([])
    with open(infile_lossless) as f:
        next(f)
        for line in f:
            columns = line.rstrip('\n').split()
            read_id,chrm,strand,pos,log_prob,motif = columns[0],columns[1],columns[2],\
                                                    columns[3],float(columns[4]),columns[7]
            if motif == methylation_motif:
                if log_prob >= log_threshold:
                    ground_truth_calls.add((read_id,chrm,strand,pos))

    num_ground_truth_calls = len(ground_truth_calls)

    # now read lossy file and create set with predicted calls
    predicted_calls = set([])
    with open(infile_lossy) as f:
        next(f)
        for line in f:
            columns = line.rstrip('\n').split()
            read_id,chrm,strand,pos,log_prob,motif = columns[0],columns[1],columns[2],\
                                                    columns[3],float(columns[4]),columns[7]
            if motif == methylation_motif:
                if log_prob >= log_threshold:
                    predicted_calls.add((read_id,chrm,strand,pos))
    
    num_predicted_calls = len(predicted_calls)
    TP = len(ground_truth_calls.intersection(predicted_calls))
    precision = TP/len(predicted_calls)
    recall = TP/num_ground_truth_calls
    return num_ground_truth_calls,num_predicted_calls,precision,recall

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Input')
    parser.add_argument('--infile_lossless', type=str, required=True, help='per read methylation tsv for lossless mode')
    parser.add_argument('--infile_lossy', type=str, required=True, help='per read methylation tsv for lossy mode')
    parser.add_argument('--methylation_type', type=str, required=True, help='can be either dam or dcm')
    parser.add_argument('--threshold', type=float, required=False, default=0.75, help='threshold for calling methylation (between 0 and 1)')
    args = parser.parse_args()
    # check that methylation_type is correct
    if args.methylation_type not in ['dcm','dam']:
        raise RuntimeError('Invalid methylation type')
    assert 0.0 < args.threshold <= 1.0
    num_ground_truth_calls, num_predicted_calls, precision, recall =\
           evaluate_methylation(args.infile_lossless,\
                                args.infile_lossy,\
                                args.methylation_type,\
                                args.threshold)
    print('# ground truth calls\t# predicted calls\tPrecision\tRecall')
    print(str(num_ground_truth_calls)+'\t'+str(num_predicted_calls)+\
            '\t'+('%.5f' % precision)+'\t'+('%.5f' % recall))
