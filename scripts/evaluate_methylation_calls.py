#!/usr/bin/env python3
'''
Script to evaluate methylation calling for lossless and lossy compression.
Works with per read methylation tsv files generated by megalodon.
First reads a bisulfite file to get a set of high-quality positions (both positive and negative)
For each compression mode, outputs total ground truth positive and negative, 
total positive and negative calls (with 0.5 probability threshold), 
false positive and false negative calls (with 0.5 probability threshold), 
precision, recall and area under ROC curve.
'''

import os
import sklearn.metrics
import numpy as np

WORKINGDIR = os.environ['WORKINGDIR']

INDIR = WORKINGDIR+'/data/NA12878/experiments/megalodon_output/'
# directory with per read methylation tsv files generated by megalodon

NUM_EXPERIMENTS = 10
# number of maxerror values for lossy compression: expect files from 1 to NUM_EXPERIMENTS

BED_FILE = WORKINGDIR+'/data/NA12878/ENCFF835NTC.bed'
# bed file with bisulfite sequencing results

COVERAGE_THRESHOLD = 5 # minimum coverage in bisulfite to treat 
            
# get list of high confidence positions from bedmethyl (bisulfite)
# coverage on both strands >= coverage_thr
# 100% positive or 100% negative
# skip Y chromosomes
# based on DeepSignal paper: https://academic.oup.com/bioinformatics/article/35/22/4586/5474907
# returns two sets (positive, negative) containing (chrom,pos,strand)
def get_high_confidence_positions(path, coverage_thr):
    set_true = set([])
    set_false = set([])
    with open(path) as f:
        for line in f:
            columns = line.rstrip('\n').split('\t')
            chrom, pos, strand, coverage, percent_meth =\
                columns[0], int(columns[1]), columns[5], columns[9], columns[10]
            if chrom == 'chrY':
                continue

            if int(coverage) >= coverage_thr:
                if float(percent_meth) == 100.0:
                    set_true.add((chrom, pos, strand))
                elif float(percent_meth) == 0.0:
                    set_false.add((chrom, pos, strand))
                
    both_strand_set_true = set([])
    both_strand_set_false = set([])
    
    for (chrom, pos, strand) in set_true:
        if strand == '+':
            new_elem = (chrom,pos+1,'-')
            if new_elem in set_true:
                both_strand_set_true.add((chrom, pos, strand))
                both_strand_set_true.add(new_elem)
    for (chrom, pos, strand) in set_false:
        if strand == '+':
            new_elem = (chrom,pos+1,'-')
            if new_elem in set_false:
                both_strand_set_false.add((chrom, pos, strand))
                both_strand_set_false.add(new_elem)
    return both_strand_set_true, both_strand_set_false                
 
    
# evaluate per read methylation produced by megalodon
def evaluate_methylation(high_confidence_positive, high_confidence_negative, path):
    # arrays to store predicted probabilities and ground truth prediction at
    # high confidence sites
    predicted = []
    ground_truth = []
    with open(path) as f:
        next(f)
        for line in f:
            columns = line.rstrip('\n').split()
            chrm,strand,pos,log_prob = columns[1],columns[2],\
                                                    int(columns[3]),float(columns[4])
            chrm = 'chr'+chrm
            strand = '+' if strand == '1' else '-'
            found = None
            if (chrm,pos,strand) in high_confidence_positive:
                found = 1
            elif (chrm,pos,strand) in high_confidence_negative:
                found = 0
            if found is not None:
                ground_truth.append(found)
                predicted.append(log_prob)
                
    ground_truth = np.array(ground_truth)
    predicted = np.array(predicted)
    total_ground_truth_positive = np.sum(ground_truth==1)
    total_ground_truth_negative = np.sum(ground_truth==0)
    predicted_binary = predicted>np.log(0.5)
    total_predicted_positive = np.sum(predicted_binary==1)
    total_predicted_negative = np.sum(predicted_binary==0)
    false_positive = np.sum((predicted_binary==1)*(ground_truth==0))
    false_negative = np.sum((predicted_binary==0)*(ground_truth==1))
    precision = 1-false_positive/total_predicted_positive
    recall = 1-false_negative/total_ground_truth_positive
    AUC = sklearn.metrics.roc_auc_score(ground_truth,predicted)
    print(str(total_ground_truth_positive)+'\t'+str(total_ground_truth_negative)+'\t'+\
          str(total_predicted_positive)+'\t'+str(total_predicted_negative)+'\t'+\
          str(false_positive)+'\t'+str(false_negative)+'\t'+\
          '{:.5f}\t{:.5f}\t{:.5f}'.format(precision,recall,AUC))

if __name__ == '__main__':
    # get high confidence positions
    high_confidence_positive, high_confidence_negative =\
                                get_high_confidence_positions(BED_FILE,COVERAGE_THRESHOLD)
    print('Total high confidence positive sites on genome\tTotal high confidence negative sites on genome')
    print(str(len(high_confidence_positive))+'\t'+str(len(high_confidence_negative)))
    print('Label\tGround truth positive\tGround truth negative\t'+\
          'Predicted positive\tPredicted negative\t'+\
          'False positive\tFalse negative\t'+\
          'Precision\tRecall\tAUC')
    file_suffix = '.per_read_modified_base_calls.txt'
    # first do lossless
    print('lossless',end='\t')
    evaluate_methylation(high_confidence_positive,\
                         high_confidence_negative,\
                         INDIR+'lossless'+file_suffix)
    # now lossy 
    for maxerror in range(1,NUM_EXPERIMENTS+1):
        for compressor in ['LFZip','SZ']:
            prefix = compressor+'_maxerror_'+str(maxerror)
            print(prefix,end='\t')
            evaluate_methylation(high_confidence_positive,\
                                 high_confidence_negative,\
                                 INDIR+prefix+file_suffix)
